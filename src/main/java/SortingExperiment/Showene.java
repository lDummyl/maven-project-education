package SortingExperiment;


public class Showene {

/*
    public void makeShoweneTest(ArrayList<Double> points) {
        ArrayList<Double> doubles = new ArrayList<>();
        for (Double p : points) {
            doubles.add(p);
        }
        int middle = doubles.size() / 2;

        ArrayList<Double> left = new ArrayList<>();
        ArrayList<Double> right = new ArrayList<>();

        Collections.sort(doubles);

        for (int i = 0; i < middle; i++) {
            left.add(doubles.get(i));
        }

        for (int i = middle; i < doubles.size(); i++) {
            right.add(doubles.get(i));
        }

        Freq medFreqLeft = l;
        Freq medFreqRight = Freq.getMedian(right);



        Double iQR = medFreqRight.hzValue - medFreqLeft.hzValue;

        Double lowerFence = medFreqLeft.hzValue - 1.5 * iQR;
        Double upperFence = medFreqRight.hzValue + 1.5 * iQR;


        System.out.println(lowerFence);
        System.out.println(upperFence);

        ArrayList<Double> badPoints = new ArrayList<>();
        for (Freq d :
                doubles) {
            if (d.hzValue > upperFence || d.hzValue < lowerFence) {
                badPoints.add(d.hzValue);
                System.out.println(d);
            }
        }
   //     throw new RuntimeException("");
        return badPoints;


    }
    }
*/

// TODO: 10/20/20 вот давай в дженерики поиграй, напиши реализацию для Double и потом примени к своим точкам фильтр по полученным границам
//  если не будет получаться просто замени дженерики на Double а потом найди способ их вернуть.

}

